// Generated by LiveScript 1.4.0
(function(){
  var csv, fs, q, minimist, shelljs, influx, execSync, argv, update, only, genmap, influxHost, influxDb, influxUser, influxPass, file, header, client, records, onEntry, toString$ = {}.toString;
  csv = require('csv');
  fs = require('fs');
  q = require('q');
  minimist = require('minimist');
  shelljs = require('shelljs');
  influx = require('influx');
  execSync = require('sync-exec');
  argv = minimist(process.argv.slice(2)), update = argv.update, only = argv.only, genmap = argv.genmap, influxHost = argv.influxHost, influxDb = argv.influxDb, influxUser = argv.influxUser, influxPass = argv.influxPass;
  file = argv._[0];
  records = [];
  if (influxHost) {
    client = influx({
      host: influxHost,
      username: influxUser,
      password: influxPass,
      database: influxDb
    });
  }
  onEntry = function(hospital_sn, it, cb){
    var normalized, res$, key, val, ref$;
    if ('Array' === toString$.call(it).slice(8, -1)) {
      console.log('===', hospital_sn, "array found");
      it = it[0];
    }
    res$ = {};
    for (key in it) {
      val = it[key];
      res$[key.toLowerCase()] = val;
    }
    normalized = res$;
    console.log('ENTRY', normalized);
    if (hospital_sn !== normalized.hospital_sn) {
      console.log('====', hospital_sn, normalized.hospital_sn);
    }
    if (!deepEq$(it, normalized, '===')) {
      console.log('FIXME', it);
    }
    normalized.time = (ref$ = normalized.update_time, delete normalized.update_time, ref$) * 1000;
    normalized.time || (normalized.time = new Date().getTime());
    delete normalized.hosptial_sn;
    normalized.hospital_sn == null && (normalized.hospital_sn = hospital_sn);
    return client != null ? client.writePoint('ER', normalized, {}, cb) : void 8;
  };
  csv().from.stream(fs.createReadStream(file, 'utf-8')).on('record', function(row, index){
    var i;
    if (index === 0) {
      return header = row;
    } else if (index > 1 && row[0]) {
      return records.push((function(){
        var resultObj$ = {};
        for (i in row) {
          resultObj$[header[i]] = row[i];
        }
        return resultObj$;
      }()));
    }
  }).on('end', function(){
    var r;
    if (genmap) {
      console.log(JSON.stringify({
        hospital_name: (function(){
          var i$, ref$, len$, resultObj$ = {};
          for (i$ = 0, len$ = (ref$ = records).length; i$ < len$; ++i$) {
            r = ref$[i$];
            resultObj$[r.hospital_sn] = r.abbr_zh;
          }
          return resultObj$;
        }())
      }, null, 4));
      return;
    }
    if (only) {
      records = records.filter(function(it){
        return it.hospital_sn == only;
      });
    }
    q.allSettled(records.map(function(r){
      var dir, ref$, php, python, ls, cmd, script, d;
      dir = "crawlers/" + r.hospital_sn;
      console.log(dir);
      if (update) {
        if (fs.existsSync(dir)) {
          if (fs.existsSync(dir + "/.git")) {
            process.chdir(dir);
            execSync.run("git pull origin master");
            process.chdir("../..");
          } else {
            execSync.run("git submodule init " + dir);
            execSync.run("git submodule update " + dir);
          }
        } else {
          execSync.run("git submodule add " + r.scraper + " " + dir);
        }
      }
      if ((ref$ = shelljs.ls(dir + "/*.php")) != null) {
        php = ref$[0];
      }
      if ((ref$ = shelljs.ls(dir + "/*.py")) != null) {
        python = ref$[0];
      }
      if ((ref$ = shelljs.ls(dir + "/*.ls")) != null) {
        ls = ref$[0];
      }
      ref$ = (function(){
        switch (false) {
        case !php:
          return ["php", php];
        case !python:
          return ["python", python];
        case !ls:
          return ["lsc", ls];
        default:
          throw "wtf " + dir;
        }
      }()), cmd = ref$[0], script = ref$[1];
      d = q.defer();
      shelljs.exec(cmd + " " + script, function(code, output){
        var res, that;
        res = (function(){
          try {
            return JSON.parse(output);
          } catch (e$) {}
        }());
        if (that = res) {
          return onEntry(r.hospital_sn, that, function(){
            return d.resolve();
          });
        } else {
          console.log('FAIL', r.hospital_sn, code, script);
          return d.resolve();
        }
      });
      return d.promise;
    }).then);
    return console.log('allresolved');
  });
  function deepEq$(x, y, type){
    var toString = {}.toString, hasOwnProperty = {}.hasOwnProperty,
        has = function (obj, key) { return hasOwnProperty.call(obj, key); };
    var first = true;
    return eq(x, y, []);
    function eq(a, b, stack) {
      var className, length, size, result, alength, blength, r, key, ref, sizeB;
      if (a == null || b == null) { return a === b; }
      if (a.__placeholder__ || b.__placeholder__) { return true; }
      if (a === b) { return a !== 0 || 1 / a == 1 / b; }
      className = toString.call(a);
      if (toString.call(b) != className) { return false; }
      switch (className) {
        case '[object String]': return a == String(b);
        case '[object Number]':
          return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);
        case '[object Date]':
        case '[object Boolean]':
          return +a == +b;
        case '[object RegExp]':
          return a.source == b.source &&
                 a.global == b.global &&
                 a.multiline == b.multiline &&
                 a.ignoreCase == b.ignoreCase;
      }
      if (typeof a != 'object' || typeof b != 'object') { return false; }
      length = stack.length;
      while (length--) { if (stack[length] == a) { return true; } }
      stack.push(a);
      size = 0;
      result = true;
      if (className == '[object Array]') {
        alength = a.length;
        blength = b.length;
        if (first) {
          switch (type) {
          case '===': result = alength === blength; break;
          case '<==': result = alength <= blength; break;
          case '<<=': result = alength < blength; break;
          }
          size = alength;
          first = false;
        } else {
          result = alength === blength;
          size = alength;
        }
        if (result) {
          while (size--) {
            if (!(result = size in a == size in b && eq(a[size], b[size], stack))){ break; }
          }
        }
      } else {
        if ('constructor' in a != 'constructor' in b || a.constructor != b.constructor) {
          return false;
        }
        for (key in a) {
          if (has(a, key)) {
            size++;
            if (!(result = has(b, key) && eq(a[key], b[key], stack))) { break; }
          }
        }
        if (result) {
          sizeB = 0;
          for (key in b) {
            if (has(b, key)) { ++sizeB; }
          }
          if (first) {
            if (type === '<<=') {
              result = size < sizeB;
            } else if (type === '<==') {
              result = size <= sizeB
            } else {
              result = size === sizeB;
            }
          } else {
            first = false;
            result = size === sizeB;
          }
        }
      }
      stack.pop();
      return result;
    }
  }
}).call(this);
